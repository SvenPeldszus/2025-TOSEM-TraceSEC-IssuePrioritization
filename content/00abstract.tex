\begin{abstract}
Code-based analyzers often find too many potentially security-related issues to address them all. Therefore, issues likely to lead to vulnerabilities should be fixed first. Such prioritization requires project-specific knowledge, such as quality requirements, security-related decisions, and design, which is not accessible to code analyzers. We present TraceSEC, an automated technique for prioritizing issues according to their security-related importance to the project. Its core concept is to incorporate available design artifacts and trace links between them, thus considering the project context that the code lacks. We reduce the problem of issue prioritization to a maximum flow problem and quantify the importance of each issue by the flow from user-defined quality aspects to the issue, i.e., quantifying its impact on project-specific security preferences. Our evaluation shows that TraceSEC effectively provides automated prioritization and can be tailored to project-specific quality goals. Its prioritization correlates stronger with manual expert prioritization than SonarQube rule severities, which are commonly used in practice. In particular, TraceSEC has a higher similarity for identifying high-priority issues. %Even projects with only imperfect traceability or planning artifacts benefit from
TraceSEC scales reasonably well for codebases up to 4~million lines of code, and the initial setup overhead is likely to be recouped after the first automated prioritization.
%
%Static code analysis plays an essential role in the quality assurance of software systems, especially concerning security. However, code-based static analyzers often detect too many potential security issues to resolve them all with reasonable effort. Therefore, issues that are likely to lead to vulnerabilities should be fixed first. Such prioritization requires a lot of information about the project, such as quality requirements, security-related decisions, and design. Code-based static analyzers do not have this information and therefore cannot properly assess the importance of issues. Also, the prioritization of detection rules cannot fully reflect the importance as perceived by developers. We present TraceSEC, an automated approach to prioritizing issues in a codebase according to their security-related importance to the project. The key concept is to include in the prioritization artifacts that are created manually during development anyway, thus capturing the project context that is not available in the source code, and the trace links between them. Prioritization starts from a quality model in which experts and stakeholders determine the relative importance of quality aspects, e.g. related to security, and follows trace links across different artifacts, such as requirements and design models, to the issue locations in the source code. We reduce the problem of trace-based issue prioritization to a maximum flow problem and quantify the importance of each issue by the flow of user-defined quality aspects to it. Our evaluation shows that TraceSEC effectively provides automated prioritization and can be tailored to project-specific quality goals. The prioritization has a stronger Spearman rank correlation at a significance level of 0.01 with a manual expert prioritization than one based on the SonarQube rule severities, and in particular, has a higher similarity for identifying high-priority issues. We show that our technique scales reasonably well for codebases of up to 4~million lines of code on a developer notebook.
\end{abstract}

%CCS Concepts https://dl.acm.org/ccs#
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011006</concept_id>
       <concept_desc>Software and its engineering~Software notations and tools</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10002978.10002986</concept_id>
       <concept_desc>Security and privacy~Formal methods and theory of security</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10002978.10003006</concept_id>
       <concept_desc>Security and privacy~Systems security</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011074</concept_id>
       <concept_desc>Software and its engineering~Software creation and management</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Software notations and tools}
\ccsdesc[500]{Security and privacy~Formal methods and theory of security}
\ccsdesc[500]{Security and privacy~Systems security}
\ccsdesc[300]{Software and its engineering~Software creation and management}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{static code analysis, security issues, traceability, issue prioritization}

%\begin{IEEEkeywords}
%static code analysis, security issues, traceability, issue prioritization
%\end{IEEEkeywords}